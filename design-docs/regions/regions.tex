\documentclass[a4paper,9pt]{article}
\usepackage{zed-cm}
\usepackage{graphicx}
\markboth{Draft}{Draft}
\pagestyle{myheadings}
\begin{document}
\parskip 6 pt
\parindent 0 pt

\title{Regions in Virgo (v0.3)}
\author{Glyn Normington\\Steve Powell}

\maketitle
\thispagestyle{myheadings}
\pagenumbering{alph}
\setcounter{page}{0}

%=============================================================================
The aim is to model how Virgo divides the OSGi framework into a connected graph
of \textit{regions}.

The model will inform the work on \textbf{Bug 330776} ``Re-implement user region using
framework hooks instead of nested framework''.

%\clearpage
%\pagenumbering{roman}
%\tableofcontents

% Type checking hacks
\newcommand{\true}{true}
\newcommand{\false}{false}
\renewcommand{\emptyset}{\varnothing}
\newcommand{\ModuleDefZero}{ModuleDef_0}
\newcommand{\ModuleDefOne}{ModuleDef_1}
\newcommand{\ModuleDefTwo}{ModuleDef_2}
\newcommand{\ModuleDefThree}{ModuleDef_3}
\newcommand{\ModuleDefFour}{ModuleDef_4}

%=============================================================================
\clearpage
\pagenumbering{arabic}
\section{Introduction}
\label{cha:intro}

The Virgo kernel is isolated from applications by the use of \textit{regions}.
The kernel runs in its own region and applications run in a \textit{user region}.

Virgo 2.1.0 implemented the user region as a nested framework, but Equinox
has deprecated the nested framework support in favour of \textit{framework hooks}
which are being defined for OSGi 4.3.
\textbf{Bug 330776} re-implements the user region using the OSGi framework and service
registry hooks.

Framework hooks are used to limit which bundles can `see' particular bundles
and exported packages, and service registry hooks are used to limit which bundles
can `see' particular services. `Seeing' includes both finding and being notified via lifecycle events.

Rather than allowing arbitrary hook behaviour, we limit the hooks to operate on regions
which are connected together with filters.

A \textit{region} is then a set of bundles and a region can see bundles, exported packages, and services
from another region via a \textit{connection}. Each connection has a \textit{filter} which may limit
what can be seen across the connection.
Hence regions and connections form a directed graph decorated by filters.

For example, Figure \ref{fig:conn} shows three regions connected by three connections.
Each connection has a filter which limits what bundles, exported packages, and services
are visible across the connection.

\begin{figure}[h!]
\begin{center}
\includegraphics*[scale=0.35]{connected-regions.pdf}
\caption{Connected Regions}
\end{center}
\label{fig:conn}
\end{figure}

A connection may be thought of as an import. So region C imports from region B.
The imports are filtered, so filter h may limit what region C sees from region B.
Similarly region A imports from region B through filter f and region B imports from region A through
filter g.

Unlike OSGi package imports between bundles, imports between regions are transitive.
So region C can see bundles, exported packages, and services from region A, subject to filters g and h.

\subsection{Resolver Hook}

The resolver hook limits the exported packages that the bundles in a given region may wire to, depending on
the region containing the bundle that exports each candidate exported package and the filters between the
regions.

For example, Figure \ref{fig:pfilt} shows a bundle Z being resolved which imports packages p and q. Bundle X
in region B exports both p and q while bundle Y in region B exports only p.

Region A is connected to region B with a filter that allows only package p to be seen by region A.
The net effect is that the import of p may be satisfied by either bundle X or Y but the import of package q may not
be satisfied by bundle X since q is filtered out.
\begin{figure}[h!]
\begin{center}
\includegraphics*[scale=0.4]{package-filtering.pdf}
\caption{Package Filtering}
\end{center}
\label{fig:pfilt}
\end{figure}

Another example in Figure \ref{fig:tpfilt} shows a package p transitively visible through two filters via an
intermediate region.

Bundle Z may wire to bundle X or bundle Y for package p, but not for packages q and r which are both
filtered out on the way from C to A.
\begin{figure}[h!]
\begin{center}
\includegraphics*[scale=0.4]{transitive-package-filtering.pdf}
\caption{Transitive Package Filtering}
\end{center}
\label{fig:tpfilt}
\end{figure}

%=============================================================================
\clearpage
\section{Basic Types}
\label{cha:basics}

Some basic types need defining.

\subsection*{Bundles}

Bundles are identified by a bundle symbolic name and bundle version, but uniquely identified in the
OSGi framework by a bundle location.
\begin{zed}
  [BSN, BVer, BLoc]
\end{zed}

\subsection*{Packages}

We abstract the notion of package version and the attributes associated with package imports and exports.
\begin{zed}
  [Package]
\end{zed}

\subsection*{Services}

We abstract all the details of services.
\begin{zed}
  [Service]
\end{zed}

\subsection*{Regions}

Regions are identified by a region identifer.
\begin{zed}
  [RId]
\end{zed}

%=============================================================================
\clearpage
\section{Bundle}
\label{cha:bundle}

A bundle has a bundle symbolic name and bundle version, exports zero or more packages, and
publishes zero or more services.

\begin{schema}{Bundle}
  name : BSN \\
  version : BVer \\
  location : BLoc \\
  exportedPackages : \power Package \\
  publishedServices : \power Service \\
\end{schema}
It is unusual, and usually bad practice, to include the primary key (in this case the location) of
an entity in the entity's schema.
We do it here to ensure that all bundles are
distinct and use this property later when determining which region a bundle belongs to.

We define a helper function for extracting a pair consisting of the bundle symbolic name and bundle
version from a bundle. 
\begin{axdef}
  bid : Bundle \fun (BSN \cross BVer) \\
\where
  bid =  (\lambda Bundle @ (name, version)) \\
\end{axdef}

%=============================================================================
\clearpage
\section{Region}
\label{cha:region}

We build up to a definition of a region in several small steps.

\subsection{Proto-Region}

A proto-region contains a set of bundles.
\begin{schema}{ProtoRegion}
  bundles : \power Bundle \\
\end{schema}

\subsection{Indexed Region}

An indexed region adds some indices, and thereby some constraints, to a proto-region.

An indexed region contains a set of bundles each of which is uniquely identified \textit{within the region}
by its bundle symbolic name and bundle version and by its location.

The indices are a function identifying the bundles in the region by
symbolic name and version and a function identifying the bundles in the region by location.
\begin{schema}{IndexedRegion}
  ProtoRegion \\
  nv : BSN \cross BVer \pinj Bundle \\
  l : BLoc \pinj Bundle \\
\where
  nv = \{ b : bundles @ (bid~b) \mapsto b \} \\
  l = \{ b : bundles @ b.location \mapsto b \} \\
\end{schema}

\subsection{OpenRegion}

An open region is an indexed region with some derived sets of packages exported by bundles in the region
and services published by bundles in the region.

\begin{schema}{OpenRegion}
  IndexedRegion \\
  localPkg : \power Package \\
  localSvc : \power Service \\
\where
  localPkg = \bigcup \{ b : bundles @ b.exportedPackages \} \\
  localSvc = \bigcup \{ b : bundles @ b.publishedServices \} \\
\end{schema}

\subsection{LinkedRegion}

A linked region is an indexed region with additional sets of imported packages and services.

\begin{schema}{LinkedRegion}
  OpenRegion \\
  importedPkg : \power Package \\
  importedSvc : \power Service \\  
\end{schema}

\subsection{Region}

A region is a linked region with derived sets of all packages and all services.
\begin{schema}{Region}
  LinkedRegion \\
  pkg : \power Package \\
  svc : \power Service \\
\where
  pkg = localPkg \cup importedPkg \\
  svc = localSvc \cup importedSvc \\
\end{schema}

A bundle can be added to a region provided the region does not already contain a bundle with
the given bundle's symbolic name and bundle version or a bundle with the given bundle's location.
\begin{schema}{AddBundleOk}
  \Delta Region \\
  b? : Bundle \\
\where
  (bid~b?) \notin \dom nv \\
  b?.location \notin \dom l \\
  bundles' = bundles \cup \{ b? \} \\
  importedPkg' = importedPkg \\
  importedSvc' = importedSvc \\
\end{schema}

We define some helper functions.
\begin{axdef}
  regionBundles : Region \fun \power Bundle \\
\where
 regionBundles = (\lambda Region @ bundles) \\
\end{axdef}
\begin{axdef}
  regionPkgs : Region \fun \power Package \\
\where
 regionPkgs = (\lambda Region @ pkg) \\
\end{axdef}
\begin{axdef}
  regionSvcs : Region \fun \power Service \\
\where
 regionSvcs = (\lambda Region @ svc) \\
\end{axdef}
\begin{axdef}
  regionLoc : Region \fun (BLoc \pinj Bundle) \\
\where
 regionLoc = (\lambda Region @ l) \\
\end{axdef}

We define a nil region.
\begin{axdef}
  NIL : Region \\
\where
 NIL.bundles = \emptyset \\
 NIL.importedPkg = \emptyset \\
 NIL.importedSvc = \emptyset \\
 \end{axdef}

%%inop \sqcup 3
Regions with consistent indexing may be combined to produce a composite region using the infix $\sqcup$ operator.
\begin{axdef}
 \_ \sqcup \_ : Region \cross Region \pfun Region \\
\where
 (\_ \sqcup \_) = (\lambda r1, r2 : Region @ \\
\t3 (\mu Region | \\
\t4 bundles = r1.bundles \cup r2.bundles \land \\
\t4 pkg = r1.pkg \cup r2.pkg \land \\
\t4 svc = r1.svc \cup r2.svc)) \\
\end{axdef}
The precondition of $\sqcup$ is that the input regions have consistent bundle spaces, that is no bundle in one
region has the same symbolic name and version as a bundle in the other region.
Also, no bundle in one region has the same location as a bundle in the other region.

$\sqcup$ is idempotent, commutative, and associative and $NIL$ acts as a zero.
\begin{argue}
  \shows \forall r, s,t : Region | \{ (r, s), (s, t), (t, r) \} \subseteq \dom(\_ \sqcup \_) @ \\
\t1 (r, r) \in \dom(\_ \sqcup \_) \land r \sqcup r = r \land \\
\t1 (s, r) \in \dom(\_ \sqcup \_) \land r \sqcup s = s \sqcup r \land \\
\t1 (r, s \sqcup t) \in \dom(\_ \sqcup \_) \land (r \sqcup s, t) \in \dom(\_ \sqcup \_) \land r \sqcup (s \sqcup t) = (r \sqcup s) \sqcup t \land \\
\t1 (r, NIL) \in \dom(\_ \sqcup \_) \land r \sqcup NIL = NIL \\
\end{argue}

We define the set of all pairwise consistent regions
\begin{zed}
  ConsistentRegionPairs == \dom(\_ \sqcup \_) \\
\end{zed}
and the set of all pairwise consistent finite sets of regions.
\begin{zed}
  ConsistentRegionSets == \{ f : \finset Region | \forall r, s : f @ (r, s) \in ConsistentRegionPairs \} \\
\end{zed}

Since $\sqcup$ is commutative and associative, so we define a distributed form.
\begin{axdef}
  \bigsqcup : \finset Region \pfun Region \\
\where
  \bigsqcup \emptyset = NIL \land \\
  (\forall r : Region; f : ConsistentRegionSets | \{ r \} \cup f \in ConsistentRegionSets @ \\
\t1 \bigsqcup( \{ r \} \cup f ) = r \sqcup \bigsqcup f) \\ 
\end{axdef}
  
%=============================================================================
\clearpage
\section{Multiple Regions}
\label{cha:multiregions}

A system of multiple regions has an indexed collection of regions, a set of bundles known to the
system, a set of exported packages, and a set of services.
The regions partition the set of all known bundles, the exported packages, and the services.
Bundles in the system of multiple regions are uniquely identified by their location.

The system also have a convenience function for determining a bundle's region identifier
and a convenience set containing all the valid region identifiers.
\begin{schema}{Regions}
  reg : RId \pfun Region \\
  allBundles : \power Bundle \\
  allPackages : \power Package \\
  allServices : \power Service \\
  ls : BLoc \pinj Bundle \\
  breg : Bundle \pfun RId \\
  rids : \power RId \\
\where
 (regionBundles \circ reg) \partition allBundles \\
 (regionPkgs \circ reg) \partition allPackages \\
 (regionSvcs \circ reg) \partition allServices \\
 breg = (\lambda b : allBundles @ (\mu rid : \dom reg | b \in regionBundles~(reg~rid))) \\
 rids = \dom reg \\
 (regionLoc \circ reg) \partition ls \\
\end{schema}

Each bundle in the system has an associated region.
\begin{argue}
  Regions \shows \dom breg = allBundles \\
\end{argue}
This follows easily from $(regionBundles \circ reg) \partition allBundles$.

We expose the convenience function as an operation for determining a bundle's region.
This function is well defined thanks to the preceding theorem.
\begin{schema}{GetRegionOk}
  \Xi Regions \\
  b? : Bundle \\
  r! : Region \\
\where
  b? \in allBundles \\
  r! = reg(breg~b?) \\
\end{schema}

%=============================================================================
\clearpage
\section{Filters}
\label{cha:filters}

A filter specifies sets of bundles, exported packages, and services.
\begin{schema}{Filter}
  bf : \power (BSN \cross BVer) \\
  pf : \power Package \\
  sf : \power Service \\
\end{schema}

We define some helper functions to perform filtering.
\begin{axdef}
  xb : Bundle \cross Filter \fun Bundle
\where
  xb = (\lambda b: Bundle; f : Filter @ \\
\t1  (\mu Bundle | \\
\t2 name = b.name \land \\
\t2 version = b.version \land \\
\t2 location = b.location \land \\
\t2 exportedPackages = b.exportedPackages \cap f.pf \land \\
\t2 publishedServices = b.publishedServices \cap f.sf))
\end{axdef}

\begin{axdef}
  fb : \power Bundle \cross Filter \fun \power Bundle \\
\where
  fb = (\lambda bs : \power Bundle; f : Filter @ \{ b : bs | (bid~b) \in f.bf @ xb(b, f) \}) \\
\end{axdef}

\begin{axdef}
  fp : \power Package \cross Filter \fun \power Package \\
\where
  fp = \{ ps : \power Package; f : Filter @ ((ps, f), ps \cap f.pf) \}
\end{axdef}

\begin{axdef}
  fs : \power Service \cross Filter \fun \power Service \\
\where
  fs = \{ ss : \power Service; f : Filter @ ((ss, f), ss \cap f.sf) \}
\end{axdef}

We also define the most permissive filter.
\begin{axdef}
  TOP : Filter
\where
  TOP.bf = BSN \cross BVer \\
  TOP.pf = Package \\
  TOP.sf = Service \\
\end{axdef}

%%inop \wr 3
We define an infix $\wr$ operator to apply a filter to a region and produce another region.
\begin{axdef}
  \_ \wr \_ : Region \cross Filter \fun Region \\
\where
  (\_ \wr \_) = (\lambda r : Region;  f : Filter @ \\
\t3   (\mu Region | \\
\t4 bundles = \{ b : r.bundles | (bid~b) \in f.bf @ xb(b, f) \} \land \\
\t4 nv = f.bf \dres r.nv \land \\
\t4 l = nv \circ bid \circ r.l \land \\
\t4 pkg = r.pkg \cap f.pf \land \\
\t4 svc = r.svc \cap f.sf )) \\
\end{axdef}
$\wr$ is total since packages and services not filtered out which are exported or published by a
bundle which \textit{is} filtered out end up
in the resultant region's imported packages and imported services sets, respectively.

The most permissive filter can be applied to any region without effect.
\begin{argue}
  \shows \forall r : Region @ r \wr TOP = r \\
\end{argue}

Filters can be applied in any order with the same effect.
\begin{argue}
  \shows \forall r : Region; f, g : Filter @ (r \wr f) \wr g = (r \wr g) \wr f \\
\end{argue}

%=============================================================================
\clearpage
\section{Connected Regions}
\label{cha:connregions}

Regions are connected by filters.
Every region is connected to itself by the most permissive filter.
So the bundles in a region can see all the bundles, exported packages, and services in that region.
\begin{schema}{ConnectedRegions}
  Regions \\
  filter : RId \cross RId \pfun Filter \\
  squash : RId \pfun Region \\
\where
  first~\limg \dom filter \rimg = rids \\
  second~\limg \dom filter \rimg = rids \\
  (\forall rid : rids @ filter(rid, rid) = TOP) \\
  \dom squash = rids \\
  (\forall rid : rids @ \\
\t1 (\LET r == reg~rid @ \\
\t2 squash(rid) = r \sqcup \bigsqcup \{ r2 : RId | (rid, r2) \in \dom filter \land r2 \neq rid @ \\
\t3 squash(r2) \wr filter(rid,r2) \}))\\
\end{schema}

%=============================================================================
\clearpage
\section{Hooks}
\label{cha:hooks}

We now describe the behaviour of the hooks in terms of the system of connected regions.

\begin{schema}{BundleFindHook}
  \Xi ConnectedRegions \\
  finder? : Bundle \\
  candidates? : \power Bundle \\
  found! : \power Bundle \\
\where
  finder? \in allBundles \\
  found! = candidates? \cap (squash(breg~finder?)).bundles \\
\end{schema}

\begin{schema}{BundleEventHook}
  \Xi ConnectedRegions \\
  listeners? : \power Bundle \\
  eb? : Bundle \\
  fl! : \power Bundle \\
\where
  listeners? \subseteq allBundles \\
  fl! = \{ l : listeners? | eb? \in (squash(breg~l)).bundles \} \\
\end{schema}

\begin{schema}{ResolveHookFilterMatches}
  \Xi ConnectedRegions \\
  requirer? : Bundle \\
  candidates? : \power Package \\
  filtered! : \power Package \\
\where
  requirer? \in allBundles \\
  filtered! = candidates? \cap (squash(breg~requirer?)).pkg \\
\end{schema}

\begin{schema}{ServiceFindHook}
  \Xi ConnectedRegions \\
  finder? : Bundle \\
  candidates? : \power Service \\
  found! : \power Service \\
\where
  finder? \in allBundles \\
  found! = candidates? \cap (squash(breg~finder?)).svc \\
\end{schema}

\begin{schema}{ServiceEventHook}
  \Xi ConnectedRegions \\
  listeners? : \power Bundle \\
  es? : Service \\
  fl! : \power Bundle \\
\where
  listeners? \subseteq allBundles \\
  fl! = \{ l : listeners? | es? \in (squash(breg~l)).svc \} \\
\end{schema}


%=============================================================================
\newpage
\section{Z Notation}
\label{cha:znot}

\makeatletter % the following code is taken from Mike Spivey's zed.tex

\def\symtab{\setbox0=\vbox\bgroup \def\\{\cr}
        \halign\bgroup\strut$##$\hfil&\quad##\hfil\cr}
\def\endsymtab{\crcr\egroup\egroup
        \dimen0=\ht0 \divide\dimen0 by2 \advance\dimen0 by\ht\strutbox
        \splittopskip=\ht\strutbox \vbadness=10000
        \predisplaypenalty=0
        $$\halign{##\cr\hbox to\linewidth{% 
                \valign{##\vfil\cr
                        \setbox1=\vsplit0 to\dimen0 \unvbox1\cr 
                        \noalign{\hfil}\unvbox0\cr
                        \noalign{\hfil}}}\cr 
                \noalign{\prevdepth=\dp\strutbox}}$$
        \global\@ignoretrue}

\makeatother 

Numbers:
\begin{symtab}
        \nat & \verb/Natural numbers/ \{\verb/0,1,.../\} \\
%       \num & \verb/Integers (...,-1,0,1,...)/ \\
%       \nat_1 & \verb/Positive natural numbers/ \\
%       \upto & \verb/integral range/ \\
%       + & \verb/Addition/\quad\hfill 3 \\
%       - & \verb/Subtraction/\quad\hfill 3 \\
%       * & \verb/Multiply/\quad\hfill 4 \\
%       \div & \verb/Remainder/\quad\hfill 4 \\
%       \mod & \verb/Modulus/\quad\hfill 4 \\
%       < & \verb/Less than/ \\
%       > & \verb/Greater than/ \\
%       \leq & \verb/Less than or equal/ \\
%       \geq & \verb/Greater than or equal/ \\
%       \neq & \verb/Inequality/ \\
\end{symtab}
Propositional logic and the schema calculus:
\begin{symtab}
%       \lnot & \verb/Not/ \\
        \ldots\land\ldots & \verb/And/ \\
        \ldots\lor\ldots & \verb/Or/ \\
        \ldots\implies\ldots & \verb/Implies/ \\
%       \iff & \verb/If and only if/ \\
        \forall..\mid..\spot.. & \verb/For all/ \\
        \exists..\mid..\spot.. & \verb/There exists/ \\
%       \exists_1..\mid..\spot.. & \verb/There exists unique/ \\
        \ldots\hide\ldots & \verb/Hiding/ \\
%       \project & \verb/\project/ \\
%       \pre & \verb/\pre/ \\
%       \semi & \verb/\semi/
        \ldots\defs\ldots & \verb/Schema definition/ \\
        \ldots==\ldots & \verb/Abbreviation/ \\
        \ldots::=\ldots\mid\ldots & \verb/Free type definition/ \\
        \ldata\ldots\rdata & \verb/Free type injection/ \\
        [\ldots] & \verb/Given sets/ \\
        ',?,!,_0\ldots_9 & \verb/Schema decorations/ \\
        \ldots\shows\ldots & \verb/theorem/ \\
        \theta\ldots & \verb/Binding formation/ \\
        \lambda\ldots & \verb/Function definition/ \\
        \mu\ldots & \verb/Mu-expression/ \\
        \Delta\ldots & \verb/State change/ \\
        \Xi\ldots & \verb/Invariant state change/ \\
\end{symtab}
Sets and sequences:
%and bags:
\begin{symtab}
        \{\ldots\} & \verb/Set/ \\
        \{..\mid..\spot..\} & \verb/Set comprehension/ \\
        \power\ldots & \verb/Set of subsets of/ \\
%       \power_1 & \verb/Non-empty subsets of/ \\
%       \finset & \verb/Finite sets/ \\
%       \finset_1 & \verb/Non-empty finite sets/ \\
        \emptyset & \verb/Empty set/ \\
        \ldots\cross\ldots & \verb/Cartesian product/ \\
        \ldots\in\ldots & \verb/Set membership/ \\
        \ldots\notin\ldots & \verb/Set non-membership/ \\
        \ldots\cup\ldots & \verb/Union/ \\
        \ldots\cap\ldots & \verb/Intersection/ \\
        \ldots\setminus\ldots & \verb/Set difference/ \\
        \bigcup\ldots & \verb/Distributed union/ \\
%       \bigcap & \verb/Distributed intersection/ \\
        \#\ldots & \verb/Cardinality/ \\
%       \dcat & \verb/Distributed sequence concatenation/
        \ldots\subseteq\ldots & \verb/Subset/ \\
        \ldots\subset\ldots & \verb/Proper subset/ \\
        \ldots\partition\ldots & \verb/Set partition/ \\
        \seq & \verb/Sequences/ \\
%       \seq_1 & \verb/Non-empty sequences/ \\
%       \iseq & \verb/Injective sequences/ \\
        \langle\ldots\rangle & \verb/Sequence/ \\
%       \cat & \verb/Sequence concatenation/ \\
        \disjoint\ldots & \verb/Disjoint sequence of sets/ \\
%       \bag & \verb/Bags/ \\
%       \lbag\ldots\rbag & \verb/Bag/ \\
%       \inbag & \verb/Bag membership/ \\
\end{symtab}
%Here are the infix function symbols. Each symbol is
%shown with its priority:
%\begin{symtab}
%       \uplus & \verb/\uplus/ \\
%       \filter & \verb/Schema projection/ \\
%       \uminus & \verb/\uminus/
%\end{symtab}
Functions and relations:
\begin{symtab}
        \ldots\rel\ldots  & \verb/Relation/ \\
        \ldots\pfun\ldots & \verb/Partial function/ \\
        \ldots\fun\ldots  & \verb/Total function/ \\
        \ldots\pinj\ldots & \verb/Partial injection/ \\
        \ldots\inj\ldots  & \verb/Injection/ \\
%       \psurj & \verb/Partial surjection/ \\
%       \surj & \verb/Surjection/ \\
%       \bij  & \verb/Bijection/ \\
%       \ffun & \verb/Finite partial function/ \\
%       \finj & \verb/Finite partial injection/ \\
        \dom\ldots & \verb/Domain/ \\
        \ran\ldots & \verb/Range/ \\
        \ldots\mapsto\ldots & \verb/maplet/ \\
        \ldots\inv & \verb/Relational inverse/ \\
%       \ldots\plus & \verb/Transitive closure/ \\
        \ldots\star & \verb/Reflexive-transitive closure/ \\
%       \ldots\bsup n \esup & \verb/Relational iteration/ \\
        \ldots\limg\ldots\rimg & \verb/Relational image/ \\
%       \comp & \verb/Forward relational composition/ \\
%       \circ & \verb/Relational composition/ \\
        \ldots\oplus\ldots & \verb/Functional overriding/ \\
        \ldots\dres\ldots & \verb/Domain restriction/ \\
%       \ldots\rres\ldots & \verb/Range restriction/ \\
        \ldots\ndres\ldots & \verb/Domain subtraction/ \\
%       \ldots\nrres\ldots & \verb/Range subtraction/ \\
%       \id & \verb/Identity relation/ \\
\end{symtab}
Axiomatic descriptions:
%%unchecked
\begin{axdef}
  Declarations
\where
  Predicates
\end{axdef}
Schema definitions:
%%unchecked
\begin{schema}{SchemaName}
  Declaration
\where
  Predicates
\end{schema}
\end{document}
