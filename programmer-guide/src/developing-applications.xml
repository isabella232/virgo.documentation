<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
		"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="developing-applications">
	<title>Developing Applications</title>
	<para>
		Applications that take advantage of the OSGi capabilities of the @tomcat.product.name@
		are typically comprised of multiple bundles. Each bundle may have dependencies on
		other bundles. Furthermore, each bundle exposes only certain packages and
		services. In this chapter, we look at how to create bundles, import and export
		appropriate functionality, and create artifacts to deploy web applications on the @tomcat.product.name@. 
	</para>
	<section id="developing-applications-bundle">
		<title>Anatomy of a Bundle</title>
		<tip>
			<para>
				This is an abbreviated introduction to OSGi bundles. Please refer to the
				<ulink url="http://static.springframework.org/osgi/docs/current/reference/html/"> 
				Spring Dynamic Modules for OSGi documentation</ulink> for full details.
			</para>
		</tip>
		<para>
			An OSGi bundle is simply a jar file with metadata that describe
			additional characteristics such as version and imported and exported packages.
		</para>
		<para>
			A bundle exports types and publishes services to be used by other bundles:
		</para>
		<itemizedlist>
			<listitem>
				<para>
					<emphasis role="bold">Types</emphasis>:
					via the OSGi <code>Export-Package</code> directive,
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">Services</emphasis>:
					via Spring-DM&rsquo;s <code>&lt;service ... /&gt;</code> XML namespace element.
				</para>
			</listitem>
		</itemizedlist>

		<para>
			A bundle may import types and services exported by other bundles:
		</para>
		<itemizedlist>
			<listitem>
				<para><emphasis role="bold">Types</emphasis>:
				via the OSGi <code>Import-Package</code> directive,</para>
			</listitem>
			<listitem>
				<para><emphasis role="bold">Services</emphasis>:
				via Spring-DM&rsquo;s <code>&lt;reference ... /&gt;</code> XML namespace element.</para>
			</listitem>
		</itemizedlist>

		<para>
			Let&rsquo;s see an example from the PetClinic sample application. The following listing shows the
			<filename>MANIFEST.MF</filename> file for the <code>org.springframework.petclinic.infrastructure.hsqldb</code> bundle.
		</para>
		<programlisting>
Manifest-Version: 1.0
<emphasis role="bold">Bundle-ManifestVersion</emphasis>: 2
<emphasis role="bold">Bundle-Name</emphasis>: PetClinic HSQL Database Infrastructure
<emphasis role="bold">Bundle-SymbolicName</emphasis>: org.springframework.petclinic.infrastructure.hsqldb
<emphasis role="bold">Bundle-Version</emphasis>: 1.0
<emphasis role="bold">Import-Library</emphasis>: org.springframework.spring;version="[2.5,2.6]"
<emphasis role="bold">Import-Bundle</emphasis>: com.springsource.org.apache.commons.dbcp;version="[1.2.2.osgi,1.2.2.osgi]",
 com.springsource.org.hsqldb;version="[1.8.0.9,1.8.0.9]"
<emphasis role="bold">Import-Package</emphasis>: javax.sql
<emphasis role="bold">Export-Package</emphasis>: org.springframework.petclinic.infrastructure
		</programlisting>
		<para>
			The <code>org.springframework.petclinic.infrastructure.hsqldb</code> bundle expresses its dependencies on
			the <code>javax.sql</code> package, the Commons DBCP and HSQLDB bundles, and the Spring library (we will examine
			the details of the library artifact in <xref linkend="developing-applications-defining-libraries"/>). The Commons DBCP 
			bundle is imported at a version of exactly 1.2.2.osgi and the HSQLDB bundle is imported at a version of exactly
			1.8.0.9. The Spring library is imported at a version between 2.5 inclusive and 2.6 exclusive.
		</para>
		
		<para>
			Note that you do not specify the bundle that will provide the imported packages.
			The @tomcat.product.name@ will examine the available bundles and satisfy the required dependencies. 
		</para>
		<para>
			The following <filename>osgi-context.xml</filename> file from the PetClinic sample&rsquo;s
			<code>org.springframework.petclinic.repository.jdbc</code> bundle declares a service published by the bundle and
			references a service published by another bundle.
		</para>
		<programlisting language="xml"><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/osgi"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:beans="http://www.springframework.org/schema/beans"
    xsi:schemaLocation="http://www.springframework.org/schema/osgi  
        http://www.springframework.org/schema/osgi/spring-osgi.xsd
        http://www.springframework.org/schema/beans   
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <service id="osgiClinic" ref="clinic" interface="org.springframework.petclinic.repository.Clinic" />
    <reference id="dataSource" interface="javax.sql.DataSource"/>

</beans:beans>]]></programlisting>
		<para>
			The <code>service</code> element publishes the <code>clinic</code> bean
			(a regular Spring bean declared in the <filename>module-context.xml</filename> file) and specifies
			<code>org.springframework.petclinic.repository.Clinic</code> as the type
			of the published service.
		</para>
		<para>The <code>reference</code> elements define a <code>dataSource</code> bean that references
		    a service published by another bundle with a an interface type of <code>javax.sql.DataSource</code>.
		</para>
	</section>
  
	<section id="developing-applications-packaging">
		<title>Creating PARs and Web Applications</title>
		<para>
			The @tomcat.product.name@ supports two OSGi-oriented ways of packaging applications: the PAR format 
			and application bundles (including web bundles). The @tomcat.product.name.short@ also supports three
			distinct WAR deployment and packaging formats: standard Java EE WAR, Shared Libraries WAR, Shared Services WAR.
		</para>
		<para>
			The @tomcat.product.name.short@ also supports plans as a way to describe an application. This method is similar to a PAR 
			in that it encapsulates all the artifacts of an application as a single unit, but differs in that a plan simply 
			lists the bundles in an XML file rather than packaging all the bundles in a single JAR file.  The use of plans 
			offers additional benefits to using PARs; for this reason, we recommend their use.  For details, see 
			<link linkend="developing-applications-plans">Creating Plans</link>.
		</para>
		<section id="developing-applications-packaging-par">
			<title>PARs</title>
			<para>
				An OSGi application is packaged as a JAR file, with extension <literal>.par</literal>. A PAR artifact offers several benefits:
				<itemizedlist>
					<listitem>A PAR file has an application name, version, symbolic name, and description.</listitem>
					<listitem>The artifacts of a PAR file are scoped so that they cannot
						be shared accidentally by other applications. The scope forms a boundary for automatic
						propagation of load time weaving and bundle refresh.
						See <link linkend="developing-applications-plans-scoping">Plans and Scoping</link> for more on scoping.
					</listitem>
					<listitem>Since a PAR is scoped, its artifacts have their exported packages imported by the
						synthetic context bundle which is used for thread context class loading. So,
						for example, hibernate will be able to load classes of any of the exported
						packages of the bundles in a PAR file using the thread context class loader.</listitem>
					<listitem>The PAR file is visible to management interfaces.</listitem>
					<listitem>The PAR file can be undeployed and redeployed as a unit.</listitem>
				</itemizedlist>
				See <link linkend="developing-applications-plans-scoping">Plans and Scoping</link> for more information on scoping.
			</para>	
			<para>
				A PAR includes one or more application bundles and its manifest specifies the following
				manifest headers:
				<table id="developing-applications-packaging-par-headers-table" colsep="1" frame="all" rowsep="1">
					<title>PAR file headers</title>
					<tgroup cols="2">
						<colspec colwidth="2*" />
						<colspec colwidth="3*" />
						<thead>
							<row>
								<entry>Header</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>Application-SymbolicName</literal></entry>
								<entry>Identifier for the application which, in combination with Application-Version, uniquely identifies an application</entry>
							</row>
							<row>
								<entry><literal>Application-Name</literal></entry>					
								<entry>Human readable name of the application</entry>
							</row>
							<row>
								<entry><literal>Application-Version</literal></entry>
								<entry>Version of the application</entry>
							</row>
							<row>
								<entry><literal>Application-Description</literal></entry>
								<entry>Short description of the application</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>	
			<para>
				The following code shows an example MANIFEST.MF in a PAR file:
			<programlisting><emphasis role="bold">Application-SymbolicName</emphasis>: com.example.shop
<emphasis role="bold">Application-Version</emphasis>: 1.0
<emphasis role="bold">Application-Name</emphasis>: Online Shop
<emphasis role="bold">Application-Description</emphasis>: Example.com&rsquo;s Online Shopping Application</programlisting>
			</para>
		</section>
		<section id="developing-applications-web-application-bundles">
			<title>Web Application Bundles</title>
			<para>
				@tomcat.product.name@ supports Web Application Bundles that are compliant with the OSGi Web Applications specification. 
				The defining property of a Bundle that makes it a Web Application Bundle is a manifest header, <literal>Web-ContextPath</literal>. 
				This defines the context path the web application will be registered under. 
			</para>
			<para>
				See <link linkend="using-spring">Using Spring and Spring DM</link> for information on using Spring or Spring DM in a Web Application Bundle.
			</para>
		</section>

    </section><!-- end packaging -->

	<section id="developing-applications-plans">
		<title>Creating Plans</title>
		<para>
			Plans are similar to PARs in that they encapsulate the artifacts of an application as a single unit. As a consequence, they have similar benefits; for details of the benefits common to PARs and plans, see <link linkend="developing-applications-packaging-par">PARs</link>.
		</para>
		<para>
			Plans have the following additional benefits, which is why we recommend that you use plans rather than PARs when defining an application:
		</para>
		<itemizedlist>
			<listitem>@tomcat.product.name@ deploys the artifacts in the plan in the order in which they are listed in the XML file, which gives you complete control over deployment order.  With a PAR, the order of deployment of the included artifacts is not guaranteed.</listitem>
			<listitem>Plans describe their contents by reference (using an XML file) as opposed to PARs that are JAR files that physically contain the included artifacts.   For this reason, it is easier to share content between plans as well as update individual parts of a plan without having to physically repackage (re-JAR) it.</listitem>
			<listitem>You can enable or disable whether a plan is scoped or atomic; PARs are always scoped and atomic.</listitem>
		</itemizedlist>

		<para>
			Plans always get their dependencies from the @tomcat.product.name.short@ repository.  This means, for example, that if you drop one of the plan&rsquo;s dependencies in the <code>pickup</code> directory rather than adding it to the repository, the plan will fail to deploy because it will not find the dependency.
		</para>

		<section id="developing-applications-plans-create">
			<title>Creating the Plan XML File</title>
			<para>
				Plans are XML files that have a <code>.plan</code> file extension, such as <code>multi-artifact.plan</code>.  
				The structure of the XML file is simple: 
				the root element is <code>&lt;plan&gt;</code> with attributes specifying the name of the plan, the version, atomicity, and scoping. 
				Then, for each artifact that makes up your application, 
				you add a <code>&lt;artifact&gt;</code> element, using its attributes to specify the type of artifact and its name and version.  
				The following is a simple example of a plan&rsquo;s XML file:
			</para>
			<programlisting language="xml"><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<plan name="multi-artifact.plan" version="1.0.0" scoped="true" atomic="true"
        xmlns="http://www.eclipse.org/virgo/schema/plan"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
		        http://www.eclipse.org/virgo/schema/plan
		        http://www.eclipse.org/virgo/schema/plan/eclipse-virgo-plan.xsd">

    <artifact type="configuration" name="app-properties" version="1.0.0"/>
    <artifact type="bundle" name="com.springsource.exciting.app" version="[2.0.0, 3.1.0)"/>

</plan>]]></programlisting>
			<para>
				In the preceding example, the name of the plan is <code>multi-artifact.plan</code> and its version is <code>1.0.0</code>.  
				The plan is both scoped and atomic.    The plan contains two artifacts: one is a bundle called <code>com.springsource.exciting.app</code> and the other is a configuration file called <code>app-properties</code>.  
			</para>
			<para>
				The following table describes the attributes of the <code>&lt;plan&gt;</code> element.
			</para>

			<table id="developing-applications-plans-create-plan-attributes" colsep="1" frame="all" rowsep="1">
				<title>Attributes of the &lt;plan&gt; Element</title>
				<tgroup cols="3">
					<colspec colwidth="1*" />
					<colspec colwidth="3*" />
					<colspec colwidth="1*" />
					<thead>
						<row>
							<entry>Attribute</entry>
							<entry>Description</entry>
							<entry>Required?</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry><literal>name</literal></entry>
							<entry>Specifies the name of this plan.  @tomcat.product.name@ uses the name as one component of the unique identifier of this plan. </entry>
							<entry>Yes.</entry>
						</row>
						<row>
							<entry><literal>version</literal></entry>
							<entry>Specifies the version of this plan.  You must use OSGi version specification syntax, such as <code>2.1.0</code>. @tomcat.product.name@ uses the version as one component of the unique identifier of this plan. </entry>
							<entry>Yes.</entry>
						</row>
						<row>
							<entry><literal>scoped</literal></entry>
							<entry>Specifies whether @tomcat.product.name@ should install the artifacts into plan-specific scope so that only the application described by this plan has access to the artifacts. If you disable scoping, then @tomcat.product.name@ installs the artifacts into the global scope, which means they are then available for access by all other deployed artifacts.  Set the attribute to <code>true</code> to enable scoping or <code>false</code> to disable it.</entry>
							<entry>Yes.</entry>
						</row>
						<row>
							<entry><literal>atomic</literal></entry>
							<entry>Specifies whether you want to tie together the lifecycle of the artifacts in this plan. Making a plan atomic means that if you install, start, stop, or uninstall a single artifact in the plan, @tomcat.product.name@ escalates the event to all artifacts in the plan. Also, in an atomic plan, @tomcat.product.name@ prevents artifacts from being in inconsistent states. For example, if one artifact should fail to start, then @tomcat.product.name@ stops all artifacts in the plan.  Set this attribute to <code>true</code> to enable atomicity or <code>false</code> to disable it. </entry>
							<entry>Yes.</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			<para>
				The following table describes the attributes of the <code>&lt;artifact&gt;</code> element.
			</para>
			<table id="developing-applications-plans-create-artifact-attributes" colsep="1" frame="all" rowsep="1">
				<title>Attributes of the &lt;artifact&gt; Element</title>
				<tgroup cols="3">
					<colspec colwidth="1*" />
					<colspec colwidth="3*" />
					<colspec colwidth="1*" />
					<thead>
						<row>
							<entry>Attribute</entry>
							<entry>Description</entry>
							<entry>Required?</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry><literal>type</literal></entry>
							<entry>Specifies the type of the artifact.  Valid values are: 
		<itemizedlist>
		  <listitem><code>bundle</code>: Specifies an OSGi bundle.  Use this artifact type for WAR files and Web application bundles. </listitem>
		  <listitem><code>configuration</code>: Specifies that the artifact is a configuration file.  Configuration files contain name/value pairs that set initial values for configuration properties of a bundle.  </listitem>
		  <listitem><code>plan</code>: Specifies that the artifact is a plan. </listitem>
		  <listitem><code>par</code>: Specifies that the artifact is a PAR. </listitem>
		</itemizedlist>
		</entry>

							<entry>Yes.</entry>
						</row>
						<row>
							<entry><literal>name</literal></entry>
							<entry>Specifies the name of the artifact. 

		<para>See <link linkend="artifact-names">Artifact Names</link> for guidelines for determining the name of an artifact.</para>
							</entry>
							<entry>Yes.</entry>
						</row>
						<row>
							<entry><literal>version</literal></entry>
							<entry>Specifies the version or range of versions of this artifact that @tomcat.product.name.short@ should look up in its repositories and then install and deploy.  You must use OSGi version specification syntax, such as <code>[1.0.0, 2.0.0)</code>. </entry>
							<entry>No.  If not specified, defaults to <code>0</code>, which in OSGi means 0 to infinity, or any version.</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</section>

		<section id="names-of-artifacts">
		  	<title>Artifact Names</title>

			<para>When you create a plan, you use the <code>name</code> attribute of the <code>&lt;artifact&gt;</code> element to specify the name of all the plan&rsquo;s dependencies.  This section describes how to determine the name of an artifact, which is not always obvious.</para>
			<para>Use the following guidelines to determine the name of an artifact:</para>
		<itemizedlist>
			<listitem><para><emphasis role="bold">Bundle</emphasis>: In this context, a <emphasis>bundle</emphasis> refers to a standard OSGi bundle as well as a Web Application Bundle and a WAR file.  The name of a bundle is the value of the <code>Bundle-SymbolicName</code> header in the <code>META-INF/MANIFEST.MF</code> file of the <code>*.jar</code>. 
			If a WAR file has <code>Bundle-SymbolicName</code> header then it will be treated as a Web Application Bundle. The following <code>MANIFEST.MF</code> snippet shows a bundle with name <code>com.springsource.exciting.app</code>:</para>
			<screen>Bundle-SymbolicName: org.eclispe.virgo.exciting.app</screen>
			<para>If the bundle does not contain a <code>META-INF/MANIFEST.MF</code> file or the <literal>MANIFEST.MF</literal> doesn't contain a <code>Bundle-SymbolicName</code> header, then the name of the bundle is its filename minus the <code>.jar</code> or <code>.war</code> extension.</para>
 </listitem>
			<listitem><para><emphasis role="bold">Configuration File</emphasis>: The name of a configuration or PID (Persistent Identity) is its filename minus the <code>.properties</code> extension. The PID can also be specified within the properties file with the 
					<emphasis>service.pid</emphasis> property.
					</para>
			</listitem>
		  <listitem><para><emphasis role="bold">Plan</emphasis>: The name of a plan is the value of the required <code>name</code> attribute of the <code>&lt;plan&gt;</code> element in the plan&rsquo;s XML file.  In the following XML snippet, the plan name is <code>multi-artifact.plan</code>:</para> 
		<screen>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;plan name="<emphasis role="bold">multi-artifact.plan</emphasis>" version="1.0.0" scoped="true" atomic="true"
        xmlns="http://www.eclipse.org/virgo/schema/plan"
...</screen>
		  </listitem>
		  <listitem><para><emphasis role="bold">PAR</emphasis>: The name of a PAR is the value of the <code>Application-SymbolicName</code> header in the <code>META-INF/MANIFEST.MF</code> file of the <code>*.par</code> file.   The following <code>MANIFEST.MF</code> snippet shows a PAR with name <code>com.springsource.my.par</code>:</para>
		  <screen>Application-SymbolicName: org.eclipse.virgo.my.par</screen>
		  <para>If the PAR does not contain a <code>META-INF/MANIFEST.MF</code> file, then the name of the PAR is its filename minus the <code>.par</code> extension.</para>
		  </listitem>
		</itemizedlist>
		</section>
		
		<section id="passing-properties">
			<title>Supplying Properties to Artifacts</title>
			<para>
				It is possible to pass properties to an artifact specified in a plan. An example of this can be seen in the Admin Console plan where the context path to be used in the Admin console is passed from the plan.
			</para>
			<programlisting>
    &lt;artifact type="bundle" name="org.eclipse.virgo.apps.admin.web" version="[3.0, 4.0)"&gt;
        &lt;property name="header:Web-ContextPath" value="/admin" /&gt;
    &lt;/artifact&gt;
			</programlisting>
			<para>
				The only supported property is <literal>header</literal> which will overwrite the given manifest header with the supplied value. This should be used with care!
			</para>
		</section>

		<section id="developing-applications-plans-use">
			<title>Using the Plan</title>
			<para>
				Because a plan is a list of artifacts, rather than a physical file that contains the artifacts, there are a few additional steps you must perform before you deploy it to @tomcat.product.name.short@.  
			</para>
			<orderedlist>
				<listitem><para>Copy the artifacts that make up the plan to the <code>usr</code> repository, which by default is the <code>$SERVER_HOME/repository/usr</code> directory, where <code>$SERVER_HOME</code> refers to the top-level installation directory of @tomcat.product.name.short@.  Note that you might have configured the server differently; in which case, copy the artifacts to your custom repository directory.</para></listitem>
				<listitem><para>Restart @tomcat.product.name.short@ if the repository used is not a <emphasis>watched</emphasis> repository.</para></listitem>
				<listitem><para>After the server has started, either use the Admin Console to deploy the plan, or manually deploy it by copying the plan&rsquo;s XML file into the <code>$SERVER_HOME/pickup</code> directory. </para>
				<para>This results in @tomcat.product.name.short@ deploying the plan.</para></listitem>
				<listitem><para>To undeploy the plan, use the Admin Console, or simply delete it from the <code>$SERVER_HOME/pickup</code> directory.</para></listitem>
			</orderedlist>
		</section>

		<section id="developing-applications-plans-scoping">
		  <title>Plans and Scoping</title>
		  <para>As described in previous sections, you can specify that a plan be <emphasis>scoped</emphasis>.  This means that @tomcat.product.name@ installs the artifacts that make up the plan into a plan-specific scope so that only the application described by the plan has access to the artifacts. If you disable scoping, then @tomcat.product.name@ installs the artifacts into the global scope, which means they are available for access by all other deployed artifacts. This section describes scoping in a bit more detail.  It also describes how you can change the default behavior of scoping, with respect to services, so that a service that is in a scope can be made globally available. </para>

		   <para>If a bundle in a given scope imports a package and a bundle in the same scope exports the package, then the import may only be satisfied by the bundle in the scope, and not by any bundles outside the scope, including the global scope.   Similarly, package exports from bundles in a scope are not visible to bundles in the global scope.</para>

		   <para>If a bundle in a scope uses Spring DM (or the blueprint service) to obtain a service reference and a bundle in the same scope uses Spring DM (or the blueprint service) to publish a matching service, then the service reference may only bind to the service published in the scope (and not to any services outside the scope).  Services published by bundles in a scope are not visible to bundles in the global scope. </para>

		    <para>However, sometimes it is useful to make a service in a scope globally available to artifacts outside the scope.  To do this, publish the service with the <literal>org.eclipse.virgo.service.scope</literal> service property set to <literal>global</literal>.  Use the <literal>&lt;service-properties&gt;</literal> child element of <literal>&lt;service&gt;</literal>, as shown in the following example: </para>

		     <programlisting>&lt;service id="publishIntoGlobal" interface="java.lang.CharSequence"&gt;
  <emphasis role="bold">&lt;service-properties&gt;
    &lt;beans:entry key="org.eclipse.virgo.service.scope" value="global" /&gt;
  &lt;/service-properties&gt;</emphasis>
  &lt;beans:bean class="java.lang.String"&gt;
    &lt;beans:constructor-arg value="foo"/&gt;
  &lt;/beans:bean&gt;
&lt;/service&gt;</programlisting>

			<para>
				A scope forms a boundary for automatic propagation of load time weaving and bundle refresh.
				Additionally, a synthetic context bundle is generated for each scope. This bundle imports all the packages exported by other bundles in the scope.
				The class loader of the synthetic context bundle is used for thread context class loading. So,
				for example, hibernate will be able to load classes of any of the exported
				packages of the bundles in a scope using the thread context class loader.
			</para>
			<para>
				To ensure predictable class loading behaviour and avoid other issues associated with <emphasis>split packages</emphasis> (packages whose classes
				are split across more than one bundle), the synthetic context bundle has a restriction:
				<emphasis role="bold">no package may be exported by more than one
				bundle in the scope</emphasis>.
				If this restriction is broken, the scoped application will fail to deploy.
				This restriction can cause problems for <link linkend="scoping-and-substitutable-exports">substitutable exports</link>.
			</para>
			<section id="developing-applications-plans-scoping-webapps">
		  		<title>Web Applications and Scoping</title>
				<para>
					A Web Application Bundle (WAB) or WAR has its bundle class loader set as the TCCL, even when the WAB or WAR belongs to
					a PAR or scoped plan.
					To enable the TCCL to load classes of other bundles in the same scope as a WAB or WAR, use a WAB which imports the necessary packages.
				</para>
				<para>
					Also a WAB or WAR has its own per-application trace, independent of the per-application trace of any PAR or scoped plan to which the
					WAB or WAR belongs.
				</para>
			</section>
		</section>

	</section><!-- end plans -->

<!-- ======================================================================= -->
<!-- ======================================================================= -->

	<section id="developing-applications-configuration-artifacts">
		<title>Creating and Using Configuration Artifacts</title>
	<para>
		Applications typically include some sort of configuration data
		that might change depending on the environment in which the
		application is deployed. For example, if an application connects to a
		database server using JDBC, the configuration data would include the
		JDBC URL of the database server, the JDBC drvier, and the username and
		password that the application uses to connect to the database server.
		This information often changes as the application is deployed to
		different computers or the application moves from the testing phase to
		the production phase.
	</para>

	<para>
		@tomcat.product.name@ provides a feature called
		<emphasis>configuration artifacts</emphasis>
		that makes it very easy for you to manage this configuration data. A
		configuration artifact is simply a properties file that is made
		available at runtime using the OSGi
		<literal>ConfigurationAdmin</literal>
		service. When you create this properties file, you set the values of
		the properties for the specific environment in which you are going to
		deploy your application, and then update the metadata of your Spring
		application to use the properties file. You then deploy the
		application and properties file together, typically as a
		<link linkend="developing-applications-plans">plan</link>
		. @tomcat.product.name@ automatically creates a configuration artifact from
		the properties file, and you can manage the lifecycle of this
		configuration artifact in the same way you manage the lifecycle of
		PARs, bundles, and plans, using the Admin
		Console. Additionally, @tomcat.product.name.short@ subscribes your
		application for notification of any refresh of the configuration
		artifact and the application can then adapt accordingly, which means
		you can easily
		<emphasis>change</emphasis>
		the configuration of your application without redeploying it.
	</para>
	<para>In sum, configuration artifacts, especially when combined with
		plans, provide an excellent mechanism for managing external
		configuration data for your applications.</para>

	<para>The following sections describe the format of the configuration
		artifact, how to update the Spring application context file of your
		application so that it knows about the configuration artifact, and
		finally how to include it in a plan alongside your application.  </para>

	<para>
		As an example to illustrate the configuration artifact feature, assume
		that you have a Spring bean called
		<literal>PropertiesController</literal>
		whose constructor requires that four property values be passed to it,
		as shown in the following snippet of Java code:
	</para>
	  <programlisting>@Controller
public class PropertiesController {

    private final String driverClassName;
    private final String url;
    private final String username;
    private final String password;

    public PropertiesController(String driverClassName, String url, String username, String password) {
        this.driverClassName = driverClassName;
        this.url = url;
        this.username = username;
        this.password = password;
}</programlisting>

	  <para>In the preceding example, the <literal>PropertiesController</literal> constructor requires four property values: <literal>driverClassName</literal>, <literal>url</literal>, <literal>username</literal>, and <literal>password</literal>.  Note that the example shows just one way that a class might require property values; your application may code it another way.</para>

	  <para>Additionally, assume that the following snippet of the associated Spring application context XML file shows how the <literal>PropertiesController</literal> bean is configured:</para>

	   <programlisting>&lt;bean class="com.springsource.configuration.properties.PropertiesController"&gt;
                &lt;constructor-arg value="${driverClassName}"/&gt;
                &lt;constructor-arg value="${url}"/&gt;
                &lt;constructor-arg value="${username}"/&gt;
                &lt;constructor-arg value="${password}"/&gt;
&lt;/bean&gt;</programlisting>

	 <para>The rest of this section describes how the bean can get these property values using a configuration artifact.</para>

	<section id="developing-applications-configuration-artifacts-propfile">
	  <title>Creating the Properties File</title>

	  <para>To create a properties file that in turn will become a configuration artifact when deployed to @tomcat.product.name.short@ from which a Spring bean, such as the <literal>PropertiesController</literal> bean, will get the actual property values, follow these guidelines:</para>
	  <itemizedlist>
		<listitem><para>Create a text file in which each property is listed as a name/value pair, one pair per line.  Precede comments with a <literal>#</literal>.  For example:</para>
		  <screen># Properties for the com.springsource.configuration.properties sample

driverClassName   = org.w3.Driver
url               = http://www.springsource.com
username          = joe
password          = secret</screen>
		  <para>The example shows four properties whose name correspond to the constructor arguments of the <literal>PropertiesController</literal> Spring bean.</para></listitem>
		<listitem><para>Name the file anything you want, as long as it has a <literal>.properties</literal> extension, such as <literal>app-properties.properties</literal>.</para></listitem>
	  </itemizedlist>
	</section>

	<section id="developing-applications-configuration-artifacts-app">
	  <title>Updating Your Application</title>
	  <para>To update your application so that it "knows" about the configuration artifact, you update the application's Spring application context XML file, typically located in the <literal>WEB-INF</literal> or <literal>META-INF/spring</literal> directories (read <link linkend="using-spring">Using Spring and Spring DM</link>
	to understand which directory to use).</para>

	   <para>You use the <literal>&lt;context:property-placeholder&gt;</literal> element to specify that you want to use the @tomcat.product.name.short@ mechanism for substituting values into bean properties.  The <literal>properties-ref</literal> attribute of this element points to a <literal>&lt;osgi-compendium:cm-properties&gt;</literal> element which you use to specify the configuration artifact that contains the property values.  You set the value of the <literal>persistent-id</literal> attribute of this element equal to the name of the configuration artifact, which is the name of the properties file <emphasis>minus</emphasis> the <literal>.properties</literal> extension. </para>
	    <para>The following sample Spring application context XMl file shows everything wired together; only relevant parts of the file are shown:</para>

	    <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:context="http://www.springframework.org/schema/context"
  xmlns:osgi-compendium="http://www.springframework.org/schema/osgi-compendium"
  xsi:schemaLocation="http://www.springframework.org/schema/osgi 
    http://www.springframework.org/schema/osgi/spring-osgi-1.2.xsd
    http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
    http://www.springframework.org/schema/context 
    http://www.springframework.org/schema/context/spring-context-2.5.xsd
    http://www.springframework.org/schema/osgi-compendium 
    http://www.springframework.org/schema/osgi-compendium/spring-osgi-compendium-1.2.xsd"&gt;

...

        &lt;bean class="com.springsource.configuration.properties.PropertiesController"&gt;
                &lt;constructor-arg value="${driverClassName}"/&gt;
                &lt;constructor-arg value="${url}"/&gt;
                &lt;constructor-arg value="${username}"/&gt;
                &lt;constructor-arg value="${password}"/&gt;
        &lt;/bean&gt;

        &lt;context:property-placeholder properties-ref="configAdminProperties"/&gt;

        &lt;osgi-compendium:cm-properties id="configAdminProperties" persistent-id="app-properties"/&gt;

...

&lt;/beans&gt; </programlisting>

	</section>

	<para>The preceding example shows how the id <literal>configAdminProperites</literal> wires the <literal>&lt;context:property-placeholder&gt;</literal> and <literal>&lt;osgi-compendium:cm-properties&gt;</literal> elements together.  Based on the value of the <literal>persistent-id</literal> attribute, you must also deploy a properties file called <literal>app-properties.properties</literal> which @tomcat.product.name.short@ installs as a configuration artifact.</para>

	<section id="developing-applications-configuration-artifacts-plan">
	  <title>Adding the Configuration Artifact to a Plan</title>
	  <para>Although you can always deploy your application and associated configuration artifact using the <literal>pickup</literal> directory, we recommends that you group the two together in a plan, add the two artifacts to the repository, and then deploy the plan using the <literal>pickup</literal> directory.  The following sample plan includes the two artifacts:</para>
	  <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;plan name="multi-artifact.plan" version="1.0.0" 
         scoped="false" atomic="false"
        xmlns="http://www.eclipse.org/virgo/schema/plan"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
		        http://www.eclipse.org/virgo/schema/plan
		        http://www.eclipse.org/virgo/schema/plan/eclipse-virgo-plan.xsd"&gt;

    &lt;artifact type="configuration" name="app-properties" version="0"/&gt;
    &lt;artifact type="bundle" name="org.eclipse.virgo.configuration.properties" version="1.0.0"/&gt;
&lt;/plan&gt;</programlisting> 

	  <para>For additional information about plans, see <link linkend="developing-applications-plans">Creating Plans</link>.</para>

	</section>

	</section> <!-- end of configuration artifacts -->

<!-- ======================================================================= -->
<!-- ======================================================================= -->

	<section id="using-spring">
		<title>Using Spring and Spring DM</title>
		<para>
			@tomcat.product.name@ supports the use of Spring framework and Spring DM (specifically version 1.2.1) by application bundles.
			For detailed information, please refer to the
			<ulink url="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/">
				Spring Framework Reference Documentation
			</ulink>
			and the
			<ulink url="http://static.springframework.org/osgi/docs/current/reference/html/">
				Spring Dynamic Modules Reference Guide
			</ulink>.
		</para>
		<para>
			Spring (and Spring DM) application context XML files should generally be placed in a bundle's <literal>META-INF/spring</literal> directory, but
			for a web application, these files must be placed in the <literal>WEB-INF</literal> directory.
		</para>
		<tip>
			<title>
				A common mistake
			</title>
			<para>
				Placing a web application's Spring application context XML files in the <literal>META-INF/spring</literal> directory produces
				unpredictable results since	Spring DM will attempt to build an application context independently of, and asynchronously from,
				the web application.
			</para>
		</tip>
		<para>
			To use Spring DM from a web application, the <literal>contextClass</literal> servlet parameter and the servlet context listener
			should be configured (in <literal>WEB-INF/web.xml</literal>) like this:
<programlisting language="xml"><![CDATA[
	<context-param>
		<param-name>contextClass</param-name>
		<param-value>org.eclipse.virgo.web.dm.ServerOsgiBundleXmlWebApplicationContext</param-value>
	</context-param>

	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>
]]></programlisting>
		</para>
	</section> <!-- end of using Spring and Spring DM -->
	
<!-- ======================================================================= -->
<!-- ======================================================================= -->

	<section id="developing-applications-programmatic-access">
		<title>Programmatic Access to the Servlet Context</title>
		<para>
			This section describes how to programmatically access the servlet context to obtain the WebApplicationContext or the BundleContext. 
		</para>
		<section id="developing-applications-programmatic-access-web">
			<title>Programmatic Access to Web Features</title>

			<section id="developing-applications-programmatic-access-web-application-context">
				<title>Programmatic Access to the WebApplicationContext</title>
				<para>
					The @tomcat.product.name@ automatically creates a <literal>WebApplicationContext</literal>
					for Web Application Bundles and WAR files. When used in conjunction with an
					an auto-configured Spring MVC <literal>DispatcherServlet</literal>,
					there is generally no need to access the <literal>WebApplicationContext</literal>
					programmatically, since all components of the web application are configured
					within the scope of the <literal>WebApplicationContext</literal>
					itself. However, if you wish to access the <literal>WebApplicationContext</literal>
					you can do so via the web application&rsquo;s <literal>ServletContext</literal>.
					@project.name@ stores the bundle&rsquo;s
					<literal>WebApplicationContext</literal> in the ServletContext under
					the attribute name "<literal>BSN-ApplicationContext</literal>", where
					<literal>BSN</literal> is the <literal>Bundle-SymbolicName</literal>
					of your WAR or Web Application Bundle.
				</para>
				<para>
					Alternatively, since @project.name@ also stores the
					<literal>WebApplicationContext</literal> under the attribute name
					with the value of the <literal>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</literal>
					constant, you may choose to use Spring MVC&rsquo;s WebApplicationContextUtils&rsquo;
					<literal>getWebApplicationContext(servletContext)</literal>
					or
					<literal>getRequiredWebApplicationContext(servletContext)</literal>
					methods to access the <literal>WebApplicationContext</literal> without providing
					an explicit attribute name. 
				</para>
			</section>

			<section id="developing-applications-programmatic-access-web-bundle-context">
				<title>Programmatic Access to the BundleContext</title>
				<para>
					As required by the OSGi Web Applications specification, you can access the
					<literal>BundleContext</literal> of your WAR or Web Application Bundle via the web application&rsquo;s
					<literal>ServletContext</literal>. The bundle context is stored in the
					<literal>ServletContext</literal> under the attribute name <literal>osgi-bundlecontext</literal>.
				</para>
			</section>

		</section>
	</section>


	<section id="developing-applications-automatic-imports-web">
		<title>Web Application Manifest Processing</title>
		<para>
			@tomcat.product.name@ generates automatic package imports (i.e., via the
			<literal>Import-Package</literal> manifest header) for certain web applications.
			This section lists which packages are automatically generated.
		</para>
		<para>
			@tomcat.product.name.short@ supports Web Application Bundles (WABs) as defined by the OSGi Web Applications Specification and WAR files.
			A WAR will typically not contain any OSGi defined manifest headers.
			A WAB is distinguished from a WAR by the presence of one or more of the following OSGi defined headers:
				<itemizedlist>
					<listitem>
						<literal>Bundle-SymbolicName</literal>
					</listitem>
					<listitem>
						<literal>Bundle-Version</literal>
					</listitem>
					<listitem>	
						<literal>Bundle-ManifestVersion</literal>
					</listitem>
					<listitem>	
						<literal>Import-Package</literal>
					</listitem>
					<listitem>
						<literal>Web-ContextPath</literal>
					</listitem>
				</itemizedlist>
		</para>
		<para>
			As required by the OSGi Web Applications specification, the following defaults are applied to a WAR:
			<itemizedlist>
				<listitem>
					<literal>Bundle-ManifestVersion</literal> is set to <literal>2</literal>
				</listitem>
				<listitem>
					<literal>Bundle-SymbolicName</literal> is generated from the path from which the bundle was installed
				</listitem>
				<listitem>
					<literal>Bundle-ClassPath</literal> is set to <literal>WEB-INF/classes</literal> followed by the JARs in
					<literal>WEB-INF/lib</literal> in an unspecified order, followed by any transitive dependencies declared
					by the JARs in <literal>WEB-INF/lib</literal>
				</listitem>
				<listitem>
					<literal>Import-Package</literal> is extended in an implementation defined way, as described below
				</listitem>
			</itemizedlist>
		</para>
		<para>
			The following packages are automatically imported into WARs:		
		<itemizedlist>
			<listitem>
				<literal>javax.servlet;version="2.5"</literal>
			</listitem>
			<listitem>
				<literal>javax.servlet.http;version="2.5"</literal>
			</listitem>
			<listitem>
				<literal>javax.servlet.jsp;version="2.1"</literal>
			</listitem>
			<listitem>	
				<literal>javax.servlet.jsp.el;version="2.1"</literal>
			</listitem>
			<listitem>	
				<literal>javax.servlet.jsp.tagext;version="2.1"</literal>
			</listitem>	
			<listitem>	
				<literal>javax.el;version="1.0"</literal>
			</listitem>	
		</itemizedlist>
		</para>

		<para>
			In addition to the above-described imports, @tomcat.product.name.short@ will also
			generate automatic imports for all of the packages that are exported by the system
			bundle, unless an import for the package already exists in the WAR&rsquo;s manifest,
			or the WAR contains the package, i.e. within <literal>WEB-INF/classes</literal>,
			or in a jar file in <literal>WEB-INF/lib</literal>. When an import is generated, it
			is versioned such that it exactly matches the version or versions of the package that
			are exported from the system bundle. For example, a package that&rsquo;s exported only at
			version <literal>1.0.0</literal> will generate an import with a version of
			<literal>[1.0.0,1.0.0]</literal>, and a package that&rsquo;s exported at version
			<literal>1.0.0</literal> and version <literal>2.0.0</literal> will generate an import 
			with a version of <literal>[1.0.0,2.0.0]</literal>.
		</para>
		
		<para>
			Web Application Bundles are not subject to the above manifest processing.
			This is a change of behaviour compared to Virgo Web Server 2.1.x.
			See (see <link linkend="known-issues-web-bundle-default-headers">Default Web 
			Application Bundle Headers</link>) if you need the old behaviour until you
			have changed your WABs to match the new behaviour.
		</para>
		
		<tip>
			<title>System Bundle Package Exports</title>
			<para>
				For further details on which packages are exported by the
				OSGi system bundle, consult the <filename>java6-server.profile</filename>
				file located in the <literal>SERVER_HOME/lib</literal> directory.
			</para>
		</tip>

	</section>

	<section id="developing-applications-dependencies">
		<title>Working with Dependencies</title>
		<para>Complex enterprise frameworks such a Spring and Hibernate are typically divided into many, many different
			packages. Traditionally, if an OSGi bundle wished to make extensive use of such a framework its manifest would
			have to import a huge number of different packages. This can be an error-prone and tedious process. Furthermore,
			application developers are used to thinking in terms of their application using a framework, such as Spring, as a
			whole, rather than a long list of all the different packages that comprise the framework.
		</para>
		<para>The following figure provides a simple illustration of the complexity of only using <code>Import-Package</code>:
		</para>
		<para>
			<imagedata fileref="images/import-package.png"/>
		</para>			
		<para>The @tomcat.product.name@ reduces the need for long lists of imported packages by introducing two new manifest
			headers; <code>Import-Bundle</code> and <code>Import-Library</code>. The following figure provides an
			illustration of the simplification that these new headers offer:
	    </para>
		<para>
			<imagedata fileref="images/import-bundle_import-library.png"/>			
		</para>
		<para>
			As you can see, use of <code>Import-Bundle</code> and <code>Import-Library</code> can lead to a dramatic reduction
			in the number of imports that you need to include in an application bundle&rsquo;s manifest. Furthermore, <code>Import-Bundle</code>
			and <code>Import-Library</code> are simply aliases for <code>Import-Package</code>; at deployment time <code>Import-Bundle</code>
			and <code>Import-Library</code> header entries are automatically expanded into numerous <code>Import-Package</code> entries. This
			means that you retain the exact same semantics of using <code>Import-Package</code>, without having to go through the labourious
			process of doing so.
		</para>
		<section id="developing-applications-importing-libraries">
		    <title>Importing Libraries</title>	
			<para>A bundle in an application can declare a dependency on a library by using the
				@umbrella.product.name@ specific <code>Import-Library</code> header. This header specifies a
				comma-separated list of library symbolic names and version ranges that determine which libraries
				are imported. By default a dependency on a library is mandatory but this can be
				controlled through use of the resolution directive in exactly the same way as
				it can with <code>Import-Package</code>.
			</para>
			<programlisting>
<emphasis role="bold">Import-Library</emphasis>: org.springframework.spring;version="[2.5.4, 3.0)",
 org.aspectj;version="[1.6.0,1.6.0]";resolution:="optional"
            </programlisting>
            <para>
                This example <code>Import-Library</code> header declares a mandatory dependency on the Spring
                library at a version from 2.5.4 inclusive to 3.0 exclusive. It also declares an
                optional dependency on the AspectJ library at exactly 1.6.0.
            </para>
       </section>
       <section id="developing-applications-importing-bundles">
	       <title>Importing Bundles</title>
	       <para>A bundle in an application can declare a dependency on a bundle by using the
		   @umbrella.product.name@ specific <code>Import-Bundle</code> header. The header specifies a comma-separated 
		   list of bundle symbolic names, version ranges, and scope declarmations that determine which bundles are imported and the scope of their dependency. By default a dependency
		   on a bundle is mandatory but this can be controlled through use of the resolution directive in exactly
		   the same way as it can with <code>Import-Package</code>.
		   </para>
			<programlisting>
<emphasis role="bold">Import-Bundle</emphasis>: com.springsource.org.apache.commons.dbcp;version="[1.2.2.osgi, 1.2.2.osgi]"
           </programlisting>
			<para>
				This example <code>Import-Bundle</code> header declares a mandatory dependency on the Apache Commons
				DBCP bundle at exactly 1.2.2.osgi.
			</para>
			<section id="developing-applications-importing-bundles-disadvantages">
				<title>Disadvantages</title>
				<para>
					A disadvantage of using <code>Import-Bundle</code> or especially <code>Import-Library</code>, is that the application 
					bundle has a greater apparent fan-out than it strictly needs. An Alternative is to use a tool such as bnd or Bundlor 
					to generate the package imports of the bundle.
				</para>
			</section>
	   </section>

		<section id="developing-applications-scoping-libraries-bundles">
			<title>Scoping Bundles in an Application</title>	
			<para>
				When working with a scoped application, such as a PAR file or a plan, you might run into a situation where one of the bundles in the application (call it <code>bundleA</code>) depends on another bundle (<code>bundleB</code>) that performs a runtime task (such as class generation) that a third bundle (<code>bundleC</code>) might need to know about, although <code>bundleC</code> does not explicitly depend on <code>bundleB</code>.  
			</para>
			<para>
				For example, Hibernate uses CGLIB (code generation library) at runtime to generate proxies for persistent classes.  Assume that a domain bundle in your application uses Hibernate for its persistent objects, and thus its <code>Import-Bundle</code> manifest header includes the Hibernate bundle.  Further assume that a separate Web bundle uses reflection in its data-binding code, and thus needs to reflect on the persistent classes generated by Hibernate at runtime.  The Web bundle now has an indirect dependency on the Hibernate bundle because of these dynamically generated classes, although the Web bundle does not typically care about the details of how these classes are persisted.  One way to solve this dependency problem is to explicitly add the Hibernate bundle to the <code>Import-Bundle</code> header of the Web bundle; however, this type of explicit-specified dependency breaks the modularity of the application and is not a programming best practice.
			</para>
			<para>
				A better way to solve this problem is to specify that @tomcat.product.name@ itself dynamically import 
				the bundle (Hibernate in the example above) to all bundles in the application at runtime.  
				You do this by adding the <code>import-scope:=application</code> directive to the <code>Import-Bundle</code> header 
				of the bundle that has the direct dependency (the domain bundle in our example).  At runtime, although the Web bundle 
				does not explicitly import the Hibernate bundle, @tomcat.product.name@ implicitly imports it and thus its classes are available 
				to the Web bundle.  This mechanism allows you to declare the dependencies you need to make your application run,
				without having to make changes to your application that might limit its flexibility. 
			</para>
			<para>
				The following example shows how to use the <code>import-scope</code> directive with the <code>Import-Bundle</code> header:
			</para>
	   <programlisting>
Import-Bundle: com.springsource.org.hibernate;version="[3.2.6.ga,3.2.6.ga]";<emphasis role="bold">import-scope:=application</emphasis></programlisting>
	    <para>
		You can also set the <code>import-scope</code> directive to the (default) value <code>bundle</code>; in this case, the scope of the bundle is just the bundle itself and thus @tomcat.product.name@ does not perform any implicit importing into other bundles of the application.  
	    </para>
	    <para>
		Note that use of the <code>import-scope:=application</code> directive of the <code>Import-Bundle</code> header only makes sense when the bundle is part of a scoped application (PAR or plan);  if the bundle is not part of a scoped application, then this directive has no effect.
	    </para>
	    <para>
		Finally, because <code>import-scope:=application</code> implicitly adds a bundle import to each bundle of the PAR or plan, the impact of subsequently refreshing the imported bundle is, in general, broader than it would have been if you had not used <code>import-scope:=application</code>. This may well affect the performance of refresh.
	    </para>
	   </section>

	   <section id="developing-applications-defining-libraries">
		    <title>Defining Libraries</title>
			<para>
			    Libraries are defined in a simple text file, typically with a <code>.libd</code> suffix. This file identifies the
			    library and lists all of its constituent bundles. For example, the following is the library definition for
			    Spring 2.5.4:
			    <programlisting><emphasis role="bold">Library-SymbolicName</emphasis>: org.springframework.spring
<emphasis role="bold">Library-Version</emphasis>: 2.5.4
<emphasis role="bold">Library-Name</emphasis>: Spring Framework
<emphasis role="bold">Import-Bundle</emphasis>: org.springframework.core;version="[2.5.4,2.5.5)",
 org.springframework.beans;version="[2.5.4,2.5.5)",
 org.springframework.context;version="[2.5.4,2.5.5)",
 org.springframework.aop;version="[2.5.4,2.5.5)",
 org.springframework.web;version="[2.5.4,2.5.5)", 
 org.springframework.web.servlet;version="[2.5.4,2.5.5)",
 org.springframework.jdbc;version="[2.5.4,2.5.5)",
 org.springframework.orm;version="[2.5.4,2.5.5)",
 org.springframework.transaction;version="[2.5.4,2.5.5)",
 org.springframework.context.support;version="[2.5.4,2.5.5)",
 org.springframework.aspects;version="[2.5.4,2.5.5)",
 com.springsource.org.aopalliance;version="1.0"</programlisting>
			</para>
			<para>
				The following table lists all of the headers that may be used in a library definition:
			</para>
			<table id="developing-applications-defining-libraries-library-headers-table" colsep="1" frame="all" rowsep="1">
				<title>Library definition headers</title>
				<tgroup cols="2">
				   <colspec colwidth="2*" />
		           <colspec colwidth="5*" />
					<thead>
						<row>
							<entry>Header</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>Library-SymbolicName</entry>
							<entry>Identifier for the library</entry>
						</row>
						<row>
							<entry>Library-Version</entry>
							<entry>Version number for the library</entry>
						</row>
						<row>
							<entry>Import-Bundle</entry>
							<entry>A comma separated list of bundle symbolic names. 
							Each entry may optionally specify a version (using the <code>version=</code> directive) 
							and the scope of the import (using the <code>import-scope</code> directive).</entry>
						</row>
						<row>
							<entry>Library-Name</entry>
							<entry>Optional. The human-readable name of the library</entry>
						</row>
						<row>
							<entry>Library-Description</entry>
							<entry>Optional. A human-readable description of the library</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</section>	
		<section id="developing-applications-installing-dependencies">
		    <title>Installing Dependencies</title>
		    <para>
			    Rather than encouraging the packaging of all an application&rsquo;s dependencies within the application itself, @tomcat.product.name@
			    uses a local provisioning repository of bundles and libraries upon which an application can depend. When the @tomcat.product.name@
			    encounters an application with a particular dependency, it will automatically provide, from its provisioning repository,
			    the appropriate bundle or library.
			</para>
			<para>
			    Making a dependency available for provisioning is simply a matter of copying it to the appropriate location in the
			    @tomcat.product.name.short@&rsquo;s local provisioning repository. By default this is
			    <literal>SERVER_HOME/repository/usr</literal>. A more detailed discussion of the provisioning
			    repository can be found in the <ulink url="../../virgo-user-guide/html/index.html">User Guide</ulink>.
			</para>
	    </section>
	</section>
	<section id="developing-applications-application-trace">
		<title>Application Trace</title>
	    <para>
		    As described in the <ulink url="../../virgo-user-guide/html/index.html">User Guide</ulink> @project.name@ provides support for
		    per-application trace for PARs, scoped Plans and WABs. @project.name@ provides SLF4J with Logback logging for Event Logging and Tracing. 
		    Application trace is configured in the <literal>serviceability.xml</literal> file.
		    See the <ulink url="../../virgo-user-guide/html/index.html">User Guide</ulink> for more details.
		</para> 
    </section> 
       <section id="developing-applications-versioning">
        <title>Application Versioning</title>
        <para>
	        In much the same way that individual OSGi bundles can be versioned, @tomcat.product.name@ allows applications to be versioned. How exactly you do this depends on how you have packaged the application:  
		<itemizedlist>
	        	<listitem>If you package your application using a PAR, you version the application by using the <literal>Application-Version</literal> header in the <code>MANIFEST.MF</code> file of the PAR file.</listitem>
			<listitem>If you use a plan to describe the artifacts that make up your application, you version it by using the <code>version</code> attribute of the <code>&lt;plan&gt;</code> root element of the plan&rsquo;s XML file.</listitem>
	        	<listitem>If your application consists of a single bundle, you version it in the standard OSGi way: by using the <literal>Bundle-Version</literal> header of the <code>MANIFEST.MF</code> file of the bundle.</listitem>
		</itemizedlist>
        </para>
        <para>@tomcat.product.name@ uses an application&rsquo;s version to prevent clashes when multiple versions of the same application are deployed at
	        the same time. For example, the application trace support described in <xref linkend="developing-applications-application-trace"/>,
	        includes the application&rsquo;s name and version in the file path. This ensures that each version of the same application has its
	        own trace or logging file.
	    </para>
	</section>
</chapter>
